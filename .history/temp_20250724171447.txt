<script setup>
import { ref, reactive, computed, watch, onMounted, nextTick, onUnmounted } from 'vue';

// --- 新增：防抖工具函数 ---
function debounce(fn, delay = 300) {
  let timeoutId = null;
  return function(...args) {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => {
      fn.apply(this, args);
    }, delay);
  };
}

// --- 定义本地存储的Key ---
const LOCAL_STORAGE_KEY = 'damageProfilerState';

// --- Profiler 状态 ---
const baseAttackPercent = ref(5);
const cuttingPercent = ref(10);
const isCuttingNerfed = ref(false);
const checkHitNumber = ref(1);
//  新增：折线图范围控制状态
const lineChartRange = reactive({
  min: 0,
  max: 30,
  step: 1
});

// --- 核心计算函数 (被多个computed复用) ---
function simulateKill(baseDmg, cuttingDmg) {
    let currentHealth = 100, totalBaseDamage = 0, totalCuttingDamage = 0, hits = 0;
    if (baseDmg <= 0 && cuttingDmg <= 0) return { totalHits: 0, baseProportion: 0, cuttingProportion: 0, totalBaseDamage: 0, totalCuttingDamage: 0 };
    while (currentHealth > 0 && hits < 10000) {
        hits++;
        const cuttingHitDamage = currentHealth * (cuttingDmg / 100);
        currentHealth -= (baseDmg + cuttingHitDamage);
        totalBaseDamage += baseDmg;
        totalCuttingDamage += cuttingHitDamage;
    }
    if (currentHealth <= 0) {
      const overkill = -currentHealth;
      const lastHitDamage = baseDmg + ( (currentHealth + overkill) * (cuttingDmg/100) );
      if (lastHitDamage > 0) {
        totalBaseDamage -= overkill * (baseDmg / lastHitDamage);
        totalCuttingDamage -= overkill * ( ( (currentHealth + overkill) * (cuttingDmg/100) ) / lastHitDamage);
      }
    }
    const totalDamage = totalBaseDamage + totalCuttingDamage;
    return {
        totalHits: hits,
        baseProportion: totalDamage > 0 ? (totalBaseDamage / totalDamage) * 100 : 0,
        cuttingProportion: totalDamage > 0 ? (totalCuttingDamage / totalDamage) * 100 : 0,
        totalBaseDamage,
        totalCuttingDamage
    };
}

// --- 计算属性 ---
const killProfile = computed(() => {
    const effectiveCuttingPercent = isCuttingNerfed.value ? cuttingPercent.value / 10 : cuttingPercent.value;
    return simulateKill(baseAttackPercent.value, effectiveCuttingPercent);
});

const manualCheckResult = computed(() => { /* ... (保持不变) ... */ });

// 新增：为折线图生成数据的计算属性
const lineChartData = computed(() => {
    const labels = [];
    const baseProportions = [];
    const efficiencies = [];
    const fixedCuttingPercent = isCuttingNerfed.value ? cuttingPercent.value / 10 : cuttingPercent.value;

    // 使用用户定义的范围和步长
    for (let base = lineChartRange.min; base <= lineChartRange.max; base += lineChartRange.step) {
        labels.push(base);
        const result = simulateKill(base, fixedCuttingPercent);
        baseProportions.push(result.baseProportion);
        const efficiency = result.totalHits > 0 ? 100 / result.totalHits : 0;
        efficiencies.push(efficiency);
    }
    return { labels, baseProportions, efficiencies };
});


// --- 图表渲染 ---
const doughnutChartCanvas = ref(null);
let doughnutChartInstance = null;
function renderDoughnutChart(profileData) {
    if (!doughnutChartCanvas.value || typeof Chart === 'undefined') return;
    if (doughnutChartInstance) doughnutChartInstance.destroy();

    const ctx = doughnutChartCanvas.value.getContext('2d');
    doughnutChartInstance = new Chart(ctx, {
        type: 'doughnut',
        data: {
            labels: ['基础攻击', '切割伤害'],
            datasets: [{
                data: [profileData.totalBaseDamage, profileData.totalCuttingDamage],
                backgroundColor: ['rgb(54, 162, 235)', 'rgb(255, 99, 132)'],
                hoverOffset: 4
            }]
        },
        options: {
            responsive: true, maintainAspectRatio: false,
            plugins: {
                title: { display: true, text: '击杀总伤害构成' },
                tooltip: {
                    callbacks: {
                        // --- 核心修正 ---
                        label: function(context) {
                            const label = context.label || '';
                            const value = context.parsed || 0;
                            const totalDamage = profileData.totalBaseDamage + profileData.totalCuttingDamage;

                            // 安全检查：只有在总伤害大于0时才计算百分比
                            const percentage = totalDamage > 0 ? (value / totalDamage * 100).toFixed(2) : 0;

                            return `${label}: ${percentage}%`;
                        }
                    }
                }
            }
        }
    });
}
// 新增：折线图的Canvas ref和实例
const lineChartCanvas = ref(null);
let lineChartInstance = null;
function renderLineChart(chartData) {
    if (!lineChartCanvas.value || typeof Chart === 'undefined') return;
    if (lineChartInstance) lineChartInstance.destroy();

    const ctx = lineChartCanvas.value.getContext('2d');
    lineChartInstance = new Chart(ctx, {
        type: 'line',
        data: {
            // labels 数组保持不变，依然包含所有的数据点标签
            labels: chartData.labels,
            datasets: [
                {
                    label: '基础攻击伤害占比',
                    data: chartData.baseProportions,
                    borderColor: 'rgb(54, 162, 235)',
                    yAxisID: 'yProportion',
                    tension: 0.1,
                    pointRadius: 2, // 减小数据点半径
                },
                {
                    label: '等效输出效率 (%/Hit)',
                    data: chartData.efficiencies,
                    borderColor: 'rgb(255, 159, 64)',
                    yAxisID: 'yEfficiency',
                    tension: 0.1,
                    pointRadius: 2,
                }
            ]
        },
        options: {
            responsive: true, maintainAspectRatio: false,
            interaction: { mode: 'index', intersect: false },

            // --- 核心修改在这里 ---
            scales: {
                x: {
                    title: { display: true, text: '基础攻击伤害 (%)' },

                    // a) 自动跳过部分刻度
                    ticks: {
                        autoSkip: true, // 启用自动跳过
                        maxTicksLimit: 15, // 限制最大刻度数量，15是一个比较舒适的值

                        // b) (可选) 自定义标签格式化
                        callback: function(value, index, ticks) {
                            // value 是刻度值, index是其在原始labels数组中的索引
                            const label = this.getLabelForValue(value);
                            // 只保留小数点后两位，并加上百分号
                            return parseFloat(label).toFixed(2) + '%';
                        }
                    }
                },
                yProportion: {
                    type: 'linear', position: 'left',
                    min: 0, max: 100,
                    title: { display: true, text: '基础攻击伤害占比 (%)' }
                },
                yEfficiency: {
                    type: 'linear', position: 'right', min: 0,
                    title: { display: true, text: '等效输出 (%/Hit)' },
                    grid: { drawOnChartArea: false }
                }
            },
            // --- 修改结束 ---

            plugins: {
                tooltip: {
                    // (可选) 优化Tooltip显示
                    callbacks: {
                        title: function(tooltipItems) {
                            return '基础攻击: ' + tooltipItems[0].label.toFixed(3) + '%';
                        },
                        label: function(context) {
                            let label = context.dataset.label || '';
                            if (label) {
                                label += ': ';
                            }
                            if (context.parsed.y !== null) {
                                label += context.parsed.y.toFixed(3);
                            }
                            return label;
                        }
                    }
                }
            }
        }
    });
}

// --- 新增：数据持久化逻辑 ---
function saveData() {
  const stateToSave = {
    baseAttackPercent: baseAttackPercent.value,
    cuttingPercent: cuttingPercent.value,
    isCuttingNerfed: isCuttingNerfed.value,
    lineChartRange: lineChartRange, // reactive 对象可以直接保存
  };
  localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(stateToSave));
  console.log("State saved to localStorage.");
}

function loadData() {
  const savedState = localStorage.getItem(LOCAL_STORAGE_KEY);
  if (savedState) {
    try {
      const state = JSON.parse(savedState);
      baseAttackPercent.value = state.baseAttackPercent || 5;
      cuttingPercent.value = state.cuttingPercent || 10;
      isCuttingNerfed.value = state.isCuttingNerfed || false;

      // 合并加载范围对象，防止未来增加新属性时出错
      Object.assign(lineChartRange, state.lineChartRange);

      console.log("State loaded from localStorage.");
    } catch (e) {
      console.error("Failed to load or parse saved state:", e);
    }
  }
}

// 1. 数据持久化：创建一个统一的 watch 来保存数据
watch(
  [baseAttackPercent, cuttingPercent, isCuttingNerfed, lineChartRange],
  saveData, // 当任何受控状态变化时，只调用 saveData
  { deep: true }
);

// 2. 环形图渲染：专门监视 killProfile 数据的变化
watch(killProfile, (newData) => {
    // 使用 nextTick 确保在DOM更新后再渲染图表
    nextTick(() => {
        renderDoughnutChart(newData);
    });
}, { immediate: true }); // immediate: true 确保在组件加载时立即执行一次


// 3. 折线图渲染：这是一个昂贵的操作，我们对其应用防抖
// const debouncedRenderLineChart = debounce((newData) => {
//   renderLineChart(newData);
// }, 300); // 延迟300毫秒

// watch(lineChartData, (newData) => {
//     // 调用防抖后的版本
//     debouncedRenderLineChart(newData);
// }, { immediate: true });


onMounted(() => {
  loadData(); // 在组件挂载时加载数据
  // 注意：因为上面的 watch 都设置了 immediate: true，
  // 所以在 loadData() 之后，它们会自动运行一次来完成初始渲染。
  // 我们不再需要在 onMounted 中手动调用 render 函数。
});

onUnmounted(() => {
    if (doughnutChartInstance) doughnutChartInstance.destroy();
    if (lineChartInstance) lineChartInstance.destroy();
});

</script>