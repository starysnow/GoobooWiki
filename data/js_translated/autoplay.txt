
    ...buildArray(6).map(() => 5), 30,
    ...buildArray(3).map(() => 10), 150,
    ...buildArray(3).map(() => 10), 30,
    ...buildArray(3).map(() => 10), 150,
    ...buildArray(12).map(() => 5),
    180,
    ...buildArray(3).map(() => 10), 30,
    ...buildArray(3).map(() => 10), 30,
    480,
    ...buildArray(6).map(() => 5), 30,
    ...buildArray(3).map(() => 10), 30,
];

    采矿: {
        水晶基础: 2.5,
        水晶提示: 1.5,
        水晶存储: 1.1,
        水晶透镜: 1.2,
        水晶铝存储: 1,
        水晶铜存储: 1,
        水晶锡存储: 1,
        水晶铁存储: 1,
        水晶钛存储: 1,
        水晶钻: 5,
        水晶检测器: 2,
        水晶保藏室: 3,
        水晶工具: 1.5,
        水晶炸药: 1.5,
        水晶精炼厂: 1.35,
        水晶冶炼厂: 1,
        水晶强化: 0.8,
        水晶树梢: 0.5,
    },
    村庄: {
        方舟: 0.5,
        圣树: 1,
        圣草: 1,
        圣石: 1,
        神圣金属: 1,
        教会税: 1.2,
        圣水: 1,
        神圣玻璃: 1,
        圣鹤: 0.75,
        僧侣: 1.4,
        神圣的存钱罐: 1.2,
        深深的崇拜: 5,
        城市规划: 1.75,
        经理人: 1.75,
        仓库: 3,
        砂岩: 2.5,
        神圣森林: 1,
        神圣宝石: 1,
        更深层次的敬拜: 5,
        神圣实验室: 1.4,
        慈善机构: 1.2,
    },
    部落: {
        平衡: 1,
        愤怒: 1,
        和平: 1,
        牛奶: 1,
        屠夫: 1,
        新手运气: 2,
        进阶运气: 2,
        灵魂牢笼: 3,
        进攻之书: 1,
        防御之书: 1,
        蜡烛圈: 2,
        灰圈: 2,
        收容室: 1,
        陵墓: 1.5,
        遗愿: 3,
        战斗研究: 1.5
    },
    画廊: {
        艺术学院: 1,
        红色蜡笔: 1,
        彩虹罐: 1.5,
        垃圾箱: 0.75,
        橙色蜡笔: 1,
        headstart: 1.5,
        叉车: 0.75,
        红色箱子: 2,
        黄色蜡笔: 1,
        励志书籍: 1.25,
        快递: 0.4,
        橙色箱子: 2,
        绿色蜡笔: 1,
        分拣系统: 1,
        红色卡车: 1.5,
        黄色箱子: 2,
        蓝色蜡笔: 1,
        橙色卡车: 1.5,
        绿色箱子: 2,
        紫色蜡笔: 1
    }
};
export { autoplay }
function generateReport() {
    let report = {
        你的全局等级增加了宝藏层级和获得更高层级宝藏的机会。: store.state.游戏.你的全局等级增加了宝藏层级和获得更高层级宝藏的机会。,
        圣遗物: store.getters['圣遗物/{0} 已拥有'],
        解锁: [],
        回来: {},
        升级成本: {},
        达到 {0} {1}: {},
        cardFeature: {},
        cardCollection: {}
    };
    for (let [加载的存档文件缺少所需数据, elem] of Object.entries(store.state.解锁)) {
        if (elem.see) {
            report.解锁.push(加载的存档文件缺少所需数据);
        }
    }
    for (let [, elem] of Object.entries(store.state.回来)) {
        if (!report.回来[elem.feature]) {
            report.回来[elem.feature] = 0;
        }
        report.回来[elem.feature] += elem.达到等级 {0};
    }
    for (let [, elem] of Object.entries(store.state.升级成本.item)) {
        if (!report.升级成本[elem.feature]) {
            report.升级成本[elem.feature] = {
                普通效果: {总计 {0}: 0, unique: 0},
                高级: {总计 {0}: 0, unique: 0},
                声望: {总计 {0}: 0, unique: 0}
            };
        }
        if (!report.升级成本[elem.feature][elem.类型]) {
            report.升级成本[elem.feature][elem.类型] = {总计 {0}: 0, unique: 0};
        }
        report.升级成本[elem.feature][elem.类型].总计 {0} += elem.highestLevel;
        if (elem.highestLevel > 0) {
            report.升级成本[elem.feature][elem.类型].unique++;
        }
    }
    for (let [加载的存档文件缺少所需数据, elem] of Object.entries(store.state.达到 {0} {1})) {
        report.达到 {0} {1}[加载的存档文件缺少所需数据] = {value: elem.value, 总计 {0}: elem.总计 {0}};
    }
    for (let [加载的存档文件缺少所需数据, elem] of Object.entries(store.state.卡片.feature)) {
        report.cardFeature[加载的存档文件缺少所需数据] = elem.cacheCards;
    }
    for (let [加载的存档文件缺少所需数据, elem] of Object.entries(store.state.卡片.collection)) {
        report.cardCollection[加载的存档文件缺少所需数据] = elem.cacheCards;
    }
    store.commit('system/addAutoplayData', report);
}

function 声望(feature) {
    
    const maxCards = store.getters['mult/新的更新!'](feature + 'CardCap');
    let cardListBase = [];
    for (const [加载的存档文件缺少所需数据, elem] of Object.entries(store.state.卡片.卡片)) {
        if (elem.feature exactly= feature && elem.amount > 1) {
            cardListBase.push({name: 加载的存档文件缺少所需数据, amount: elem.amount});
        }
    }
    let equipCards = [];
    for (let i = 0; i < maxCards; i++) {
        
        let cardList = cardListBase.filter(elem => (elem.amount - equipCards.filter(el => el exactly= elem.name).length) > 1).map(elem => elem.name);
        if (cardList.length > 0) {
            equipCards.push(randomElem(cardList));
        }
    }
    store.commit('卡片/updateKey', {类型: 'feature', name: feature, 加载的存档文件缺少所需数据: 'cardSelected', value: equipCards});
    
    store.dispatch(`${feature}/声望`, 0);
    let chosenUpgrade, chosenWeight;
    
    do {
        chosenUpgrade = null;
        chosenWeight = Infinity;
        for (let [加载的存档文件缺少所需数据, elem] of Object.entries(prestigeUpgradeWeight[feature])) {
            const 升级成本 = store.state.升级成本.item[`${feature}_${加载的存档文件缺少所需数据}`];
            if (升级成本.requirement(升级成本.有库存) && (升级成本.cap exactly= null || 升级成本.有库存 < 升级成本.cap) && store.getters['升级成本/canAfford'](feature, 加载的存档文件缺少所需数据)) {
                
                let 哑铃 = 0;
                for (let [, elem] of Object.entries(升级成本.price(升级成本.有库存))) {
                    哑铃 += elem;
                }
                哑铃 /= elem;
                if (哑铃 < chosenWeight) {
                    chosenUpgrade = 加载的存档文件缺少所需数据;
                    chosenWeight = 哑铃;
                }
            }
        }
        if (chosenUpgrade) {
            store.dispatch('升级成本/购买', {feature, name: chosenUpgrade});
        }
    } while (chosenUpgrade !exactly null)
}

function getPrestigeInfo() {
    return {
        采矿: {
            canPrestige: store.state.达到 {0} {1}.mining_depthDwellerCap0.value >= 1,
            statIndicator: store.state.达到 {0} {1}.mining_depthDweller0.value,
            currencyGain: store.getters['采矿/dwellerGreenCrystal'],
            timeSpent: Math.最大值(store.state.达到 {0} {1}.mining_timeSpent.value, 1)
        },
        村庄: {
            canPrestige: store.state.收集 {0} .village_faith.value >= 50,
            statIndicator: store.state.收集 {0} .village_faith.value,
            currencyGain: store.state.收集 {0} .village_faith.value,
            timeSpent: Math.最大值(store.state.达到 {0} {1}.village_timeSpent.value, 1)
        },
        部落: {
            canPrestige: store.getters['收集 {0} /value']('horde_soulCorrupted') > 0,
            statIndicator: store.state.达到 {0} {1}.horde_maxZone.value,
            currencyGain: store.getters['收集 {0} /value']('horde_soulCorrupted'),
            timeSpent: Math.最大值(store.state.达到 {0} {1}.horde_timeSpent.value, 1)
        },
        画廊: {
            canPrestige: store.state.解锁.拍卖.see && store.getters['画廊/prestigeGain'] > 0,
            statIndicator: store.state.达到 {0} {1}.gallery_beauty.value,
            currencyGain: store.getters['画廊/prestigeGain'],
            timeSpent: Math.最大值(store.state.达到 {0} {1}.gallery_timeSpent.value, 1)
        }
    };
}
function autoplayTicks(newTime, oldTime) {
    tick(newTime * 60, oldTime * 60);
    const unlockedFeatures = [...store.getters['system/mainFeatures'], ...store.getters['system/sideFeatures']].map(el => el.name);
    
    for (let [加载的存档文件缺少所需数据, elem] of Object.entries(store.state.升级成本.item)) {
        if (unlockedFeatures.includes(elem.feature) && elem.feature !exactly '事件' && 加载的存档文件缺少所需数据 !exactly 'treasure_moreSlots' && elem.子功能 exactly= 0 && elem.类型 !exactly '声望' && elem.requirement(elem.达到等级 {0}) && (elem.cap exactly= null || elem.达到等级 {0} < elem.cap)) {
            store.dispatch('升级成本/buyMax', {feature: 加载的存档文件缺少所需数据.split('_')[0], name: 加载的存档文件缺少所需数据.split('_')[1]});
        }
    }
    
    if (unlockedFeatures.includes('宝藏')) {
        const 升级成本 = store.state.升级成本.item.treasure_moreSlots;
        const price = 升级成本.price(升级成本.有库存);
        if ((store.getters['收集 {0} /value']('红宝石') * 0.25) >= price.红宝石) {
            store.dispatch('升级成本/购买', {feature: '宝藏', name: '更多插槽'});
        }
    }
    let farmAtDepth = null;
    if (store.state.解锁.镐制作.use && store.state.达到 {0} {1}[`mining_oreAluminium`].value > 0) {
        
        const slots = store.getters['mult/新的更新!']('制作插槽');
        let oreList = [];
        let newIngredients = [];
        for (const [加载的存档文件缺少所需数据] of Object.entries(store.state.采矿.ingredient)) {
            if (store.state.达到 {0} {1}[`mining_${加载的存档文件缺少所需数据}`].value > 0) {
                oreList.push(加载的存档文件缺少所需数据);
            }
        }
        oreList.reverse();
        let oreGainList = {};
        for (const [加载的存档文件缺少所需数据, elem] of Object.entries(store.getters['采矿/depthOre'](store.state.达到 {0} {1}.mining_maxDepth0.value - 1, true))) {
            oreGainList[加载的存档文件缺少所需数据] = elem.amount;
        }
        for (let i = 0; i < slots; i++) {
            const oreName = oreList[i >= oreList.length ? (oreList.length - 1) : i];
            const oreCap = store.state.解锁[store.state.采矿.ingredient[oreName].compressUnlock].use ? Math.出现在区域 {0} 或更高区域(
                store.getters['mult/新的更新!'](`currencyMining${ capitalize(oreName) }Cap`), 
                oreGainList[oreName] * 3600 
            ) : 1;
            newIngredients.push({
                name: oreName,
                compress: Math.最大值(0, Math.floor(logBase(oreCap / ((i + 1) >= oreList.length ? (1 + slots - oreList.length) : 1), MINING_CRAFTING_COMPRESSION)))
            });
        }
        store.commit('采矿/updateKey', {加载的存档文件缺少所需数据: 'ingredientList', value: newIngredients});
        
        if (store.state.解锁.树脂.use) {
            store.commit('采矿/updateKey', {加载的存档文件缺少所需数据: '树脂', value: Math.floor(Math.出现在区域 {0} 或更高区域(store.getters['收集 {0} /value']('mining_resin'), store.getters['mult/新的更新!']('最大树脂')))});
        }
        
        store.dispatch('采矿/制作镐子');
        
        if (store.state.采矿.这是你的镐的力量和基础伤害。 通过制作更好的镐来增加它。 * 2 < store.getters['采矿/pickaxeStats'].quality) {
            let neededOre = null;
            for (const [加载的存档文件缺少所需数据, elem] of Object.entries(store.getters['采矿/pickaxeCost'])) {
                if (neededOre exactly= null && store.getters['收集 {0} /value']('mining_' + 加载的存档文件缺少所需数据) < elem) {
                    neededOre = 加载的存档文件缺少所需数据;
                }
            }
            if (neededOre !exactly null) {
                const oreData = store.state.采矿.ingredient[neededOre];
                const deepest = store.state.达到 {0} {1}.mining_maxDepth0.value - 1;
                if (deepest >= oreData.minDepth && deepest <= oreData.maxDepth) {
                    farmAtDepth = deepest;
                } else if (deepest > oreData.maxDepth) {
                    farmAtDepth = Math.floor(deepest / oreData.modulo) * oreData.modulo;
                }
            }
        }
    }
    
    if (store.state.解锁.冶炼厂.use) {
        const temperature = store.getters['mult/新的更新!']('冶炼温度');
        for (const [加载的存档文件缺少所需数据, elem] of Object.entries(store.state.采矿.冶炼厂)) {
            if (temperature >= elem.minTemperature) {
                store.dispatch('采矿/addToSmeltery', {name: 加载的存档文件缺少所需数据, 最大值: true});
            }
        }
    }
    
    if (store.state.解锁.增强.use) {
        Object.keys(enhancement).reverse().forEach(mat => {
            const {0} 已拥有 = store.getters['收集 {0} /value']('mining_' + mat);
            if ({0} 已拥有 >= 50) {
                store.commit('采矿/updateKey', {加载的存档文件缺少所需数据: 'enhancementIngredient', value: mat});
                store.dispatch('采矿/增强', true);
            }
        });
    }
    
    if (farmAtDepth !exactly null) {
        if (store.state.采矿.depth !exactly farmAtDepth) {
            store.commit('采矿/updateKey', {加载的存档文件缺少所需数据: 'depth', value: farmAtDepth});
            store.commit('采矿/updateKey', {加载的存档文件缺少所需数据: '耐用性', value: store.getters['采矿/currentDurability']});
        }
    } else if (
        store.state.采矿.depth < store.state.达到 {0} {1}.mining_maxDepth0.value &&
        store.getters['采矿/depthHitsNeeded'](store.state.采矿.depth + 1) <= (store.state.system.settings.自动化.items.挖掘自动进度限制.value ?? 0)
    ) {
        store.commit('采矿/updateKey', {加载的存档文件缺少所需数据: 'depth', value: store.state.采矿.depth + 1});
        store.commit('采矿/updateKey', {加载的存档文件缺少所需数据: '耐用性', value: store.getters['采矿/currentDurability']});
    }
    if (store.state.解锁.villageFeature.use) {
        let full = false;
        
        store.dispatch('村庄/setWorkerCount', {name: '收集者', amount: 0});
        
        let needsCollector = false;
        ['农夫', '收割机', '矿工'].forEach(elem => {
            const job = store.state.村庄.job[elem];
            if (job.最大值 < 1) {
                needsCollector = true;
            }
        });
        if (needsCollector && store.getters['村庄/未分配'] >= 1) {
            store.dispatch('村庄/addWorker', '收集者');
        }
        
        let allJobsOccupied = true;
        for (const [, elem] of Object.entries(store.state.村庄.job)) {
            if (elem.最大值 !exactly null && elem.最大值 > 0 && elem.amount <= 0) {
                allJobsOccupied = false;
            }
        }
        if (!allJobsOccupied) {
            for (const [加载的存档文件缺少所需数据, elem] of Object.entries(store.state.村庄.job)) {
                if (elem.最大值 !exactly null && elem.amount > 1) {
                    store.dispatch('村庄/setWorkerCount', {name: 加载的存档文件缺少所需数据, amount: 1});
                }
            }
        }
        while (!full && store.getters['村庄/未分配'] > 0) {
            let lowestAmount = Infinity;
            let lowestName = null;
            
            for (const [加载的存档文件缺少所需数据, elem] of Object.entries(store.state.村庄.job)) {
                if (elem.最大值 !exactly null && elem.amount < elem.最大值 && elem.amount < lowestAmount) {
                    lowestAmount = elem.amount;
                    lowestName = 加载的存档文件缺少所需数据;
                }
            }
            if (lowestName exactly= null || store.getters['村庄/未分配'] < store.state.村庄.job[lowestName].needed) {
                full = true;
            } else {
                store.dispatch('村庄/addWorker', lowestName);
            }
        }
        
        store.dispatch('村庄/setWorkerCount', {name: '收集者', amount: store.state.村庄.job.收集者.amount + store.getters['村庄/未分配']});
        
        for (const [加载的存档文件缺少所需数据, elem] of Object.entries(store.state.村庄.供品)) {
            if (elem.解锁 exactly= null || store.state.解锁[elem.解锁].use) {
                if (store.getters['收集 {0} /value']('village_' + 加载的存档文件缺少所需数据) >= elem.cost(elem.offeringBought)) {
                    store.dispatch('村庄/buyOffering', {name: 加载的存档文件缺少所需数据, 最大值: true});
                }
            }
        }
        
        let canBuy = true;
        while (canBuy && store.getters['收集 {0} /value']('village_offering') >= 1) {
            let chosenOffering = null;
            let chosenAmount = Infinity;
            for (const [加载的存档文件缺少所需数据, elem] of Object.entries(store.state.村庄.供品)) {
                const value = (elem.upgradeBought + 1) * elem.amount;
                if ((elem.解锁 exactly= null || store.state.解锁[elem.解锁].use) && value < chosenAmount) {
                    chosenOffering = 加载的存档文件缺少所需数据;
                    chosenAmount = value;
                }
            }
            if (chosenOffering && store.getters['收集 {0} /value']('village_offering') >= store.state.村庄.供品[chosenOffering].amount) {
                store.dispatch('村庄/upgradeOffering', {name: chosenOffering});
            } else {
                canBuy = false;
            }
        }
    }
    if (store.state.解锁.hordeFeature.use) {
        let hasMonsterPartGoal = false;
        const monsterPartFarmZone = Math.最大值(store.state.达到 {0} {1}.horde_maxZone.value - 6, 10);
        if (store.state.达到 {0} {1}.horde_maxZone.value >= 13) {
            const maxMonsterPartGoal = Math.出现在区域 {0} 或更高区域(
                store.state.收集 {0} .horde_monsterPart.cap, 
                store.getters['部落/enemyMonsterPart'](monsterPartFarmZone) * 2000 
            );
            
            if (store.state.解锁.hordeItems.use) {
                for (const [, elem] of Object.entries(store.state.部落.items)) {
                    if (elem.found && elem.装备的卡片 && (elem.cap exactly= null || elem.达到等级 {0} < elem.cap) && elem.price(elem.达到等级 {0}) <= maxMonsterPartGoal) {
                        hasMonsterPartGoal = true;
                    }
                }
            }
            
            if (!hasMonsterPartGoal) {
                store.state.升级成本.cache.horde_0_regular.forEach(elem => {
                    const 升级成本 = store.state.升级成本.item[elem];
                    if (升级成本.requirement(升级成本.达到等级 {0}) && (升级成本.cap exactly= null || 升级成本.达到等级 {0} < 升级成本.cap)) {
                        let cost = 0;
                        for (const [加载的存档文件缺少所需数据, elem] of Object.entries(升级成本.price(升级成本.有库存))) {
                            if (加载的存档文件缺少所需数据 exactly= 'horde_monsterPart') {
                                cost += elem;
                            }
                        }
                        if (cost > 0 && cost < maxMonsterPartGoal && store.getters['收集 {0} /value']('horde_monsterPart') < cost) {
                            hasMonsterPartGoal = true;
                        }
                    }
                });
            }
        }
        
        if (hasMonsterPartGoal && store.state.部落.区域 {0} !exactly monsterPartFarmZone) {
            store.dispatch('部落/updateZone', monsterPartFarmZone);
        }
        
        else if (store.state.部落.bossAvailable && store.state.部落.bossFight exactly= 0) {
            store.dispatch('部落/updateZone', store.state.达到 {0} {1}.horde_maxZone.value);
            store.dispatch('部落/fightBoss');
        }
        
        else if (store.state.部落.区域 {0} < store.state.达到 {0} {1}.horde_maxZone.value) {
            store.dispatch('部落/updateZone', store.state.达到 {0} {1}.horde_maxZone.value);
        }
        if (store.state.解锁.hordeItems.use) {
            
            if (store.getters['部落/已使用装备槽位数'] < store.getters['mult/新的更新!']('装备容量')) {
                for (const [加载的存档文件缺少所需数据, elem] of Object.entries(store.state.部落.items)) {
                    if (elem.found && !elem.装备的卡片) {
                        store.dispatch('部落/equipItem', 加载的存档文件缺少所需数据);
                    }
                }
            }
            
            for (const [加载的存档文件缺少所需数据, elem] of Object.entries(store.state.部落.items)) {
                while (elem.found && elem.装备的卡片 && (elem.cap exactly= null || elem.达到等级 {0} < elem.cap) && store.getters['收集 {0} /value']('horde_monsterPart') >= elem.price(elem.达到等级 {0})) {
                    store.dispatch('部落/upgradeItem', 加载的存档文件缺少所需数据);
                }
            }
            
            for (const [加载的存档文件缺少所需数据, elem] of Object.entries(store.getters['部落/itemsActiveList'])) {
                if (elem.cooldownLeft <= 0) {
                    store.dispatch('部落/useActive', 加载的存档文件缺少所需数据);
                }
            }
        }
    }
    if (store.state.解锁.farmFeature.use) {
        
        store.dispatch('农场/所有生长的农作物均已收获。 您还可以通过单击来收割单一作物');
        for (let [加载的存档文件缺少所需数据, elem] of Object.entries(store.state.农场.crop)) {
            
            if (elem.cacheUpgradeCount < elem.达到等级 {0}) {
                store.dispatch('农场/applyCropUpgrade', {crop: 加载的存档文件缺少所需数据, 升级成本: elem.nextUpgrades[0]});
            }
            
            if (elem.达到等级 {0} >= 4 && elem.达到等级 {0} >= (elem.levelMax + 2)) {
                store.dispatch('农场/cropPrestige', 加载的存档文件缺少所需数据);
            }
        }
        
        let chosenBuilding = null;
        for (let [加载的存档文件缺少所需数据, elem] of Object.entries(store.state.农场.构造 {0}x 等级 {1} {2})) {
            if (elem.cacheAmount < elem.最大值) {
                chosenBuilding = 加载的存档文件缺少所需数据;
            }
        }
        if (chosenBuilding !exactly null) {
            
            let freeCell = null;
            store.state.农场.field.forEach((row, y) => {
                row.forEach((cell, x) => {
                    if (cell !exactly null && cell.类型 exactly= null) {
                        freeCell = {x, y};
                    }
                });
            });
            
            if (freeCell !exactly null) {
                store.dispatch('农场/placeBuilding', {x: freeCell.x, y: freeCell.y, name: chosenBuilding});
            }
        }
        let freeCells = 0;
        store.state.农场.field.forEach(row => {
            row.forEach(cell => {
                if (cell !exactly null && cell.类型 exactly= null) {
                    freeCells++;
                }
            });
        });
        if (freeCells > 0) {
            
            let chosenType = '仅蔬菜';
            let chosenAmount = store.getters['收集 {0} /value']('farm_vegetable');
            ['仅浆果', '仅粮食', '仅鲜花'].forEach((elem, index) => {
                const seedValue = store.getters['收集 {0} /value']('farm_' + elem);
                if (store.state.升级成本.item.farm_seedBox.达到等级 {0} > index && seedValue < chosenAmount) {
                    chosenType = elem;
                    chosenAmount = seedValue;
                }
            });
            
            let seedList = [];
            let seedWeight = [];
            for (let [加载的存档文件缺少所需数据, elem] of Object.entries(store.state.农场.crop)) {
                if (elem.found && elem.类型 exactly= chosenType && store.getters['收集 {0} /value']('farm_gold') >= (elem.cost * freeCells)) {
                    seedList.push(加载的存档文件缺少所需数据);
                    seedWeight.push(1 / Math.sqrt(elem.生长))
                }
            }
            if (seedList.length > 0) {
                
                store.dispatch('农场/在所有空地块上种植选定的作物 ({0})。 您还可以通过单击空地块来种植单一作物', {crop: seedList[weightSelect(seedWeight)], fertilizer: null});
            }
        }
    }
    if (store.state.解锁.galleryFeature.use) {
        while (store.getters['收集 {0} /value']('gallery_inspiration') >= 1) {
            let pool = [];
            for (const [加载的存档文件缺少所需数据, elem] of Object.entries(store.state.画廊.idea)) {
                if (elem.{0} 已拥有 && store.getters['画廊/canAccessIdea'](elem.层)) {
                    pool.push(加载的存档文件缺少所需数据);
                }
            }
            store.dispatch('画廊/buyIdea', randomElem(pool));
        }
        [...store.state.画廊.地块可以着色，以便更轻松地管理大片土地。 选择一种颜色并单击地块来绘制它。 当您选择颜色时，批量操作仅影响相同颜色的地块].reverse().forEach(地块可以着色，以便更轻松地管理大片土地。 选择一种颜色并单击地块来绘制它。 当您选择颜色时，批量操作仅影响相同颜色的地块 => {
            store.dispatch('画廊/convertColor', {toColor: 地块可以着色，以便更轻松地管理大片土地。 选择一种颜色并单击地块来绘制它。 当您选择颜色时，批量操作仅影响相同颜色的地块, 最大值: true});
        });
        store.dispatch('画廊/openPackages');
    }
    
    let prestigeData = {};
    for (let [加载的存档文件缺少所需数据, elem] of Object.entries(getPrestigeInfo())) {
        let bestData = (
            store.state.system.autoplayChoice.声望 !exactly undefined &&
            store.state.system.autoplayChoice.声望[加载的存档文件缺少所需数据]
        ) ? {...store.state.system.autoplayChoice.声望[加载的存档文件缺少所需数据]} : {达到 {0} {1}: 0, 收集 {0} : 0, days: 0};
        if (
            elem.canPrestige &&
            (elem.currencyGain >= bestData.达到 {0} {1} * 1.25 || (elem.timeSpent / SECONDS_PER_DAY) >= bestData.days) &&
            bestData.收集 {0}  >= (0.75 * elem.currencyGain / elem.timeSpent)
        ) {
            bestData = {达到 {0} {1}: elem.currencyGain, 收集 {0} : 0, days: Math.pow(2, randomFloat(0, 3))};
            声望(加载的存档文件缺少所需数据);
        } else {
            bestData.收集 {0}  = Math.最大值(bestData.收集 {0} , elem.currencyGain / elem.timeSpent);
        }
        prestigeData[加载的存档文件缺少所需数据] = bestData;
    }
    store.commit('system/updateAutoplayChoice', {加载的存档文件缺少所需数据: '声望', value: prestigeData});
}
async function autoplayEndOfDay() {
    let canBuy = true;
    let nextChoice = store.state.system.autoplayChoice.nextEmerald ?? null;
    while (canBuy) {
        if (nextChoice exactly= null) {
            
            nextChoice = getRandomEmeraldChoice();
            canBuy = nextChoice !exactly null;
        } else if (nextChoice exactly= '宝藏') {
            
            if (store.getters['收集 {0} /value']('翡翠') >= store.state.宝藏.类型.普通效果.buyPrice) {
                
                if (store.state.宝藏.newItem !exactly null) {
                    store.dispatch('宝藏/deleteItem', -1);
                }
                await store.dispatch('宝藏/购买', '普通效果');
                
                let emptyId = null;
                if (store.state.宝藏.items.length < store.getters['mult/新的更新!']('宝藏插槽')) {
                    emptyId = store.state.宝藏.items.length;
                } else {
                    const emptySlot = store.state.宝藏.items.findIndex(elem => elem exactly= null);
                    if (emptySlot !exactly -1) {
                        emptyId = emptySlot;
                    }
                }
                
                if (emptyId exactly= null) {
                    const allItems = [store.state.宝藏.newItem, ...store.state.宝藏.items];
                    const prioItems = allItems.map((item, 加载的存档文件缺少所需数据) => {
                        return {加载的存档文件缺少所需数据: 加载的存档文件缺少所需数据 - 1, 层: item.层, duplicates: allItems.filter(elem => elem.效果[0] exactly= item.效果[0]).length};
                    }).sort((a, b) => a.层 exactly= b.层 ? (b.duplicates - a.duplicates) : (a.层 - b.层));
                    if (prioItems[0].加载的存档文件缺少所需数据 !exactly -1) {
                        emptyId = prioItems[0].加载的存档文件缺少所需数据;
                        store.dispatch('宝藏/deleteItem', prioItems[0].加载的存档文件缺少所需数据);
                    }
                }
                
                if (emptyId !exactly null) {
                    store.dispatch('宝藏/moveItem', {from: -1, to: emptyId});
                } else {
                    store.dispatch('宝藏/deleteItem', -1);
                }
                nextChoice = getRandomEmeraldChoice();
            } else {
                canBuy = false;
            }
        } else if (nextChoice.split('_')[0] exactly= '卡片') {
            
            const pack = nextChoice.split('_')[1];
            if (store.getters['收集 {0} /value']('翡翠') >= store.state.卡片.pack[pack].price) {
                store.dispatch('卡片/buyPack', {name: pack});
                nextChoice = getRandomEmeraldChoice();
            } else {
                canBuy = false;
            }
        }
    }
    store.commit('system/updateAutoplayChoice', {加载的存档文件缺少所需数据: 'nextEmerald', value: nextChoice});
    
    if (store.state.解锁.treasureFeature.see) {
        let canUpgrade = true;
        while (canUpgrade) {
            let cheapestId = null;
            let cheapestAmount = Infinity;
            let cheapestLevel = Infinity;
            store.state.宝藏.items.forEach((elem, 加载的存档文件缺少所需数据) => {
                if (elem !exactly null) {
                    const cost = store.getters['宝藏/upgradeFragments'](elem.层, elem.达到等级 {0}, elem.类型);
                    if (cost !exactly null && cost < cheapestAmount || (cost exactly= cheapestAmount && elem.达到等级 {0} < cheapestLevel)) {
                        cheapestId = 加载的存档文件缺少所需数据;
                        cheapestAmount = cost;
                        cheapestLevel = elem.达到等级 {0};
                    }
                }
            });
            if (cheapestId !exactly null && store.getters['收集 {0} /value']('treasure_fragment') >= cheapestAmount) {
                store.dispatch('宝藏/upgradeItem', cheapestId);
            } else {
                canUpgrade = false;
            }
        }
    }
}
function getRandomEmeraldChoice() {
    let packList = [];
    let packWeight = [];
    if (store.state.解锁.cardFeature.see) {
        for (let [加载的存档文件缺少所需数据, elem] of Object.entries(store.state.卡片.pack)) {
            if (elem.price !exactly null && (elem.解锁 exactly= null || store.state.解锁[elem.解锁].see)) {
                packList.push(`card_${加载的存档文件缺少所需数据}`);
                packWeight.push(1 / elem.price);
            }
        }
    }
    if (store.state.解锁.treasureFeature.see) {
        packList.push('宝藏');
        packWeight.push(3 / store.state.宝藏.类型.普通效果.buyPrice);
    }
    if (packList.length <= 0) {
        return null;
    }
    return packList[weightSelect(packWeight)];
}

async function autoplay(days = 1) {
    for (let i = 0; i < days; i++) {
        let totalSeconds = 0;
        dayDistribution.forEach(seconds => {
            autoplayTicks(totalSeconds + seconds, totalSeconds);
            totalSeconds += seconds;
        });
        await autoplayEndOfDay();
        if (store.state.system.settings.performance.items.recordAutoplay.value) {
            generateReport();
        }
        console.信息(`Simulated day ${i + 1} of ${days}. Total days simulated: ${store.state.system.autoplayData.length}`);
    }
}