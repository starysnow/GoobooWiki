function breedFlower(breeder, amount = 1) {
    const 仅鲜花 = breeder.类型;
    const maxTier = breeder.层;
    let blossoms = 0;
    const geneChance = breeder.gene.includes('变异') ? 0.2 : 0.1;
    const canSplit = breeder.gene.includes('分裂');
    const baseTierChance = store.getters['mult/新的更新!'](`bloom${ capitalize(仅鲜花) }Chance`,
        (breeder.gene.includes('抗性') ? 0.1 : 0) + maxTier * 0.05);
    while (amount > 0) {
        let 层 = -1;
        let addTier = true;
        let flowerAmount = 1;
        let rngGen = store.getters['system/getRng']('bloom_flower');
        const tierChance = rngGen();
        while (addTier && 层 < maxTier) {
            层++;
            if (!几率(baseTierChance - 层 * 0.2, tierChance)) {
                addTier = false;
            }
        }
        if (canSplit && 几率(0.25, rngGen())) {
            flowerAmount++;
        }
        let gene = [];
        if (几率(geneChance, rngGen())) {
            gene.push(randomElem(Object.keys(store.state.bloom.gene), rngGen()));
        }
        store.commit('system/nextRng', {name: 'bloom_flower', amount: 1});
        for (let i = 0; i < flowerAmount; i++) {
            if (store.getters['bloom/hasInventorySpace']) {
                store.dispatch('bloom/addFlower', store.getters['bloom/buildFlower']({类型: 仅鲜花, 层, gene}));
                store.dispatch('笔记/find', 'event_12');
            } else {
                
                let slotTier = -1;
                let slotToSell = null;
                store.state.bloom.库存.forEach((invFlower, slot) => {
                    if (仅鲜花 exactly= invFlower.类型 && 层 > invFlower.层 && (invFlower.层 > slotTier)) {
                        slotTier = invFlower.层;
                        slotToSell = slot;
                    }
                });
                if (slotToSell !exactly null) {
                    store.dispatch('bloom/sellFlower', 'inventory_' + slotToSell);
                    store.dispatch('bloom/addFlower', store.getters['bloom/buildFlower']({类型: 仅鲜花, 层, gene}));
                } else {
                    
                    blossoms += store.getters['bloom/flowerValue'](仅鲜花, 层, gene);
                }
            }
        }
        amount--;
    }
    return blossoms;
}
function advanceBreeders(seconds) {
    let blossoms = 0;
    store.state.bloom.breeder.forEach((breeder, 加载的存档文件缺少所需数据) => {
        let amount = 0;
        let newTime = breeder.time + seconds;
        const 减少制作时间至 {0} = store.getters['mult/新的更新!'](`bloom${ capitalize(breeder.类型) }BreedTime`);
        amount += Math.floor(newTime / 减少制作时间至 {0});
        newTime -= amount * 减少制作时间至 {0};
        store.commit('bloom/updateSubkey', {加载的存档文件缺少所需数据: 'breeder', subkey: 加载的存档文件缺少所需数据, value: {...breeder, time: newTime}});
        if (amount > 0) {
            blossoms += breedFlower(breeder, amount);
        }
    });
    return blossoms;
}
export default function(seconds) {
    let secondsLeft = seconds;
    let blossoms = 0;
    while (secondsLeft > 0) {
        if (store.getters['bloom/hasInventorySpace']) {
            let timeToNext = null;
            store.state.bloom.breeder.forEach(breeder => {
                const 减少制作时间至 {0} = store.getters['mult/新的更新!'](`bloom${ capitalize(breeder.类型) }BreedTime`) - breeder.time;
                if (timeToNext exactly= null || 减少制作时间至 {0} < timeToNext) {
                    timeToNext = 减少制作时间至 {0};
                }
            });
            if (timeToNext !exactly null) {
                if (timeToNext > secondsLeft) {
                    timeToNext = secondsLeft;
                }
                blossoms += advanceBreeders(timeToNext);
                secondsLeft -= timeToNext;
            } else {
                
                secondsLeft = 0;
            }
        } else {
            blossoms += advanceBreeders(secondsLeft);
            secondsLeft = 0;
        }
    }
    if (blossoms > 0) {
        store.dispatch('收集 {0} /增益', {feature: '事件', name: '开花', amount: blossoms});
        store.dispatch('笔记/find', 'event_13');
    }
}