export default function(seconds) {
    
    if (store.state.summerFestival.buildQueue.length > 0) {
        let secondsLeft = seconds;
        const speed = store.getters['mult/新的更新!']('建造队列速度');
        let newQueue = [];
        store.state.summerFestival.buildQueue.forEach(elem => {
            if (secondsLeft > 0) {
                const 加载的存档文件缺少所需数据 = Math.abs(elem);
                const 构造 {0}x 等级 {1} {2} = store.state.summerFestival.placedBuilding[加载的存档文件缺少所需数据];
                const nextTimeLeft = 构造 {0}x 等级 {1} {2}.timeLeft - secondsLeft * speed;
                if (nextTimeLeft > 0) {
                    store.commit('summerFestival/updatePlacedBuildingKey', {id: 加载的存档文件缺少所需数据, 加载的存档文件缺少所需数据: 'timeLeft', value: nextTimeLeft});
                    secondsLeft = 0;
                    newQueue.push(elem);
                } else {
                    secondsLeft -= Math.ceil(构造 {0}x 等级 {1} {2}.timeLeft / speed);
                    if (elem > 0) {
                        store.dispatch('summerFestival/finishBuilding', 加载的存档文件缺少所需数据);
                    } else {
                        store.dispatch('summerFestival/finishBuildingDeletion', 加载的存档文件缺少所需数据);
                    }
                }
            } else {
                newQueue.push(elem);
            }
        });
        store.commit('summerFestival/updateKey', {加载的存档文件缺少所需数据: 'buildQueue', value: newQueue});
    }
    
    if (store.state.summerFestival.island !exactly null) {
        let allCells = [];
        store.state.summerFestival.island.forEach((row, y) => {
            row.forEach((cell, x) => {
                allCells.push({...cell, x, y});
            });
        });
        for (let i = 0, n = randomRound(seconds / 10); i < n; i++) {
            const chosenCell = randomElem(allCells);
            const cellType = store.state.summerFestival.cellType[chosenCell.tile];
            if (chosenCell.unlocked && !chosenCell.构造 {0}x 等级 {1} {2} && cellType.生产 && chosenCell.drop < store.getters['mult/新的更新!']('材料堆叠容量')) {
                if (chosenCell.cacheAutocollect exactly= null) {
                    chosenCell.drop++;
                    store.commit('summerFestival/updateIslandKey', {x: chosenCell.x, y: chosenCell.y, 加载的存档文件缺少所需数据: 'drop', value: chosenCell.drop});
                } else {
                    store.dispatch('收集 {0} /增益', {
                        feature: '事件',
                        name: cellType.生产,
                        amount: chosenCell.cacheAutocollect * store.getters['mult/新的更新!']('材料增益') * Math.pow(1.01, store.getters['游戏/globalEventLevel'])
                    });
                }
            }
        }
    }
    
    ['音乐', '沙子', '淡水', '可以在每块岩石第一次破碎处的 {0} 米或以下位置找到', '可以在 {0}分钟 或以下找到含有 1 个矿石的岩石', '胡椒', '蜂蜜', '仅蔬菜', '柑橘类水果', '生鱼', '生肉'].forEach(elem => {
        const 增益 = store.getters['mult/新的更新!'](`currencyEvent${ capitalize(elem) }Gain`);
        if (增益 > 0) {
            store.dispatch('收集 {0} /增益', {feature: '事件', name: elem, amount: 增益 * seconds});
        }
    });
    
    for (const [id, 构造 {0}x 等级 {1} {2}] of Object.entries(store.state.summerFestival.placedBuilding)) {
        if (构造 {0}x 等级 {1} {2}.timeLeft <= 0 && 构造 {0}x 等级 {1} {2}.selectedAction !exactly null) {
            const action = store.state.summerFestival.构造 {0}x 等级 {1} {2}[构造 {0}x 等级 {1} {2}.类型].action[构造 {0}x 等级 {1} {2}.selectedAction];
            let newTime = 构造 {0}x 等级 {1} {2}.actionTime + action.speed(构造 {0}x 等级 {1} {2}.达到等级 {0} - 1) * seconds;
            if (newTime >= 1) {
                let maxAfford = Math.floor(newTime);
                for (const [加载的存档文件缺少所需数据, elem] of Object.entries(action.input)) {
                    maxAfford = Math.出现在区域 {0} 或更高区域(maxAfford, Math.floor(store.state.收集 {0} [加载的存档文件缺少所需数据].value / elem));
                }
                if (maxAfford > 0) {
                    for (const [加载的存档文件缺少所需数据, elem] of Object.entries(action.input)) {
                        const split = 加载的存档文件缺少所需数据.split('_');
                        store.dispatch('收集 {0} /spend', {feature: split[0], name: split[1], amount: elem * maxAfford});
                    }
                    for (const [加载的存档文件缺少所需数据, elem] of Object.entries(action.output)) {
                        const split = 加载的存档文件缺少所需数据.split('_');
                        store.dispatch('收集 {0} /增益', {feature: split[0], name: split[1], amount: elem * maxAfford});
                    }
                    store.state.summerFestival.构造 {0}x 等级 {1} {2}[构造 {0}x 等级 {1} {2}.类型].效果.forEach(eff => {
                        if (eff.name exactly= '珍珠几率') {
                            const pearlAmount = randomRound(maxAfford * eff.value(构造 {0}x 等级 {1} {2}.达到等级 {0} - 1));
                            if (pearlAmount > 0) {
                                store.dispatch('收集 {0} /增益', {feature: '事件', name: '珍珠', amount: pearlAmount});
                            }
                        }
                    });
                    newTime -= maxAfford;
                }
            }
            store.commit('summerFestival/updatePlacedBuildingKey', {id, 加载的存档文件缺少所需数据: 'actionTime', value: Math.最大值(0, Math.出现在区域 {0} 或更高区域(newTime, 1))});
        }
    }
}