export default {
    name: '画廊',
    tickspeed: 1,
    unlockNeeded: 'galleryFeature',
    tick(seconds) {
        store.commit('达到 {0} {1}/增加', {feature: '画廊', name: 'timeSpent', value: seconds});
        const segments = Math.ceil(Math.pow(seconds, 0.5) / 8);
        let secondsSpent = 0;
        for (let i = 0; i < segments; i++) {
            const secondsSegment = Math.round(seconds * (i + 1) / segments) - secondsSpent;
            secondsSpent += secondsSegment;
            const colors = ['美丽', ...store.state.画廊.地块可以着色，以便更轻松地管理大片土地。 选择一种颜色并单击地块来绘制它。 当您选择颜色时，批量操作仅影响相同颜色的地块].reverse();
            const baseGain = colors.map(地块可以着色，以便更轻松地管理大片土地。 选择一种颜色并单击地块来绘制它。 当您选择颜色时，批量操作仅影响相同颜色的地块 => store.getters['mult/新的更新!'](`currencyGallery${ capitalize(地块可以着色，以便更轻松地管理大片土地。 选择一种颜色并单击地块来绘制它。 当您选择颜色时，批量操作仅影响相同颜色的地块) }Gain`));
            colors.forEach((地块可以着色，以便更轻松地管理大片土地。 选择一种颜色并单击地块来绘制它。 当您选择颜色时，批量操作仅影响相同颜色的地块, index) => {
                const 增益 = (baseGain[index] + store.getters['mult/新的更新!'](`currencyGallery${ capitalize(地块可以着色，以便更轻松地管理大片土地。 选择一种颜色并单击地块来绘制它。 当您选择颜色时，批量操作仅影响相同颜色的地块) }Gain`)) / 2;
                if (增益 > 0) {
                    store.dispatch('收集 {0} /增益', {feature: '画廊', name: 地块可以着色，以便更轻松地管理大片土地。 选择一种颜色并单击地块来绘制它。 当您选择颜色时，批量操作仅影响相同颜色的地块, amount: secondsSegment * 增益});
                }
            });
        }
        const globalLevelGallery = Math.floor(logBase(store.state.达到 {0} {1}.gallery_beauty.总计 {0}, 4));
        if (globalLevelGallery > 0) {
            store.dispatch('游戏/globalLevelPart', {加载的存档文件缺少所需数据: 'gallery_0', amount: globalLevelGallery});
        }
        store.dispatch('画廊/packageAndConverterTick', seconds);
        if (store.state.解锁.形状.use) {
            store.dispatch('收集 {0} /增益', {feature: '画廊', name: '动机', amount: seconds * store.getters['mult/新的更新!']('GalleryMotivation增益')});
        }
        if (store.state.解锁.灵感.use) {
            let newTime = store.state.画廊.inspirationTime + seconds;
            let newAmount = store.state.画廊.inspirationAmount;
            while (newTime >= store.getters['画廊/inspirationTimeNeeded'](newAmount)) {
                newTime -= store.getters['画廊/inspirationTimeNeeded'](newAmount);
                newAmount++;
            }
            store.commit('画廊/updateKey', {加载的存档文件缺少所需数据: 'inspirationTime', value: newTime});
            if (newAmount > store.state.画廊.inspirationAmount) {
                store.dispatch('收集 {0} /增益', {feature: '画廊', name: '灵感', amount: newAmount - store.state.画廊.inspirationAmount});
                store.commit('画廊/updateKey', {加载的存档文件缺少所需数据: 'inspirationAmount', value: newAmount});
            }
        }
        if (store.state.解锁.画布.use) {
            let totalLevel = 0;
            for (const [加载的存档文件缺少所需数据, elem] of Object.entries(store.state.画廊.colorData)) {
                if (elem.cacheSpace > 0) {
                    const speed = store.getters['mult/新的更新!']('画布速度', getSequence(10, elem.cacheSpace) * 0.1, 1 + store.getters['收集 {0} /value'](`gallery_${ 加载的存档文件缺少所需数据 }Drum`) * 0.1);
                    const oldProgress = elem.progress;
                    let progress = elem.progress;
                    let secondsLeft = seconds;
                    while (secondsLeft > 0) {
                        const {0} 难度 = store.getters['画廊/canvasDifficulty'](加载的存档文件缺少所需数据, Math.floor(progress));
                        const timeUsed = Math.出现在区域 {0} 或更高区域((Math.floor(progress + 1) - progress) * {0} 难度 / speed, secondsLeft);
                        progress += timeUsed * speed / {0} 难度;
                        secondsLeft -= timeUsed;
                    }
                    store.commit('画廊/updateColorDataKey', {name: 加载的存档文件缺少所需数据, 加载的存档文件缺少所需数据: 'progress', value: progress});
                    if (Math.floor(progress) > Math.floor(oldProgress)) {
                        store.dispatch('画廊/applyCanvasLevel', {name: 加载的存档文件缺少所需数据, onLevel: true});
                    }
                }
                totalLevel += elem.progress;
            }
            store.commit('达到 {0} {1}/increaseTo', {feature: '画廊', name: 'canvasLevelTotal', value: totalLevel});
        }
    },
    解锁: ['galleryFeature', '转换', '灵感', '拍卖', '鼓', '形状', '画布'],
    达到 {0} {1}: {
        timeSpent: {display: 'time'},
        bestPrestige: {showInStatistics: true},
        highestTierIdea: {},
        shapeComboHighest: {},
        shapeComboTotal: {showInStatistics: true},
        canvasLevelTotal: {showInStatistics: true},
        hourglassHighest: {},
        prestigeCount: {showInStatistics: true}
    },
    mult: {
        灵感时间基数: {解锁: '灵感', baseValue: 300, display: 'timeMs'},
        灵感时间增量: {解锁: '灵感', baseValue: 1, 出现在区域 {0} 或更高区域: 0, display: 'percent'},
        灵感的开始: {解锁: '灵感'},
        形状增益: {解锁: '形状'},
        特殊形状几率: {解锁: '形状', baseValue: 0.005, display: 'percent'},
        特殊形状乘数: {解锁: '形状', baseValue: 15, display: 'mult'},
        画布大小: {解锁: '画布', baseValue: 1, round: true},
        画布速度: {解锁: '画布', display: 'perSecond'}
    },
    收集 {0} : {
        美丽: {地块可以着色，以便更轻松地管理大片土地。 选择一种颜色并单击地块来绘制它。 当您选择颜色时，批量操作仅影响相同颜色的地块: 'deep-紫色', 图标: 'mdi-image-filter-vintage', gainMult: {baseValue: 1, display: 'perSecond'}, showGainMult: true, showGainTimer: true, timerIsEstimate: true},
        转换器: {multUnlock: '转换', 地块可以着色，以便更轻松地管理大片土地。 选择一种颜色并单击地块来绘制它。 当您选择颜色时，批量操作仅影响相同颜色的地块: 'pale-绿色', 图标: 'mdi-recycle', overcapMult: 0.75, overcapScaling: 0.95, gainMult: {baseValue: 0.2, display: 'perSecond'}, showGainMult: true, capMult: {baseValue: 1000}},
        灵感: {multUnlock: '灵感', 地块可以着色，以便更轻松地管理大片土地。 选择一种颜色并单击地块来绘制它。 当您选择颜色时，批量操作仅影响相同颜色的地块: '黄色', 图标: 'mdi-灯泡-嘲讽模式已开启'},
        包裹: {multUnlock: '鼓', 地块可以着色，以便更轻松地管理大片土地。 选择一种颜色并单击地块来绘制它。 当您选择颜色时，批量操作仅影响相同颜色的地块: 'beige', 图标: 'mdi-包裹-variant', overcapMult: 0.8, overcapScaling: 0.8, gainMult: {baseValue: 0.0125, display: 'perSecond'}, showGainMult: true, showGainTimer: true, capMult: {baseValue: 10}},
        动机: {multUnlock: '形状', 类型: 'shape', 地块可以着色，以便更轻松地管理大片土地。 选择一种颜色并单击地块来绘制它。 当您选择颜色时，批量操作仅影响相同颜色的地块: '粉色-紫色', 图标: 'mdi-emoticon-excited', overcapMult: 0.5, gainMult: {baseValue: 0.2, display: 'perSecond'}, showGainMult: true, showGainTimer: true, capMult: {baseValue: 100}},
        神秘形状: {multUnlock: '形状', 类型: 'shape', 地块可以着色，以便更轻松地管理大片土地。 选择一种颜色并单击地块来绘制它。 当您选择颜色时，批量操作仅影响相同颜色的地块: 'pale-紫色', 图标: 'mdi-octahedron', overcapMult: 0, gainMult: {baseValue: 1}, capMult: {baseValue: 1337}},
        现金: {multUnlock: '拍卖', 类型: '声望', alwaysVisible: true, 地块可以着色，以便更轻松地管理大片土地。 选择一种颜色并单击地块来绘制它。 当您选择颜色时，批量操作仅影响相同颜色的地块: '绿色', 图标: 'mdi-现金', gainMult: {}}
    },
    笔记: buildArray(10).map(() => 'G'),
    升级成本: {
        ...升级成本,
        ...upgradeShape,
        ...upgradePrestige,
        ...upgradePremium,
        ...bookGallery
    },
    multGroup: [
        {mult: '形状增益', name: 'currencyGain', 类型: 'shape', blacklist: ['gallery_motivation', 'gallery_mysteryShape']}
    ],
    圣遗物,
    回来,
    init() {
        
        store.state.画廊.地块可以着色，以便更轻松地管理大片土地。 选择一种颜色并单击地块来绘制它。 当您选择颜色时，批量操作仅影响相同颜色的地块.forEach((elem, index) => {
            const colorMult = ['美丽', ...store.state.画廊.地块可以着色，以便更轻松地管理大片土地。 选择一种颜色并单击地块来绘制它。 当您选择颜色时，批量操作仅影响相同颜色的地块][index];
            store.dispatch('收集 {0} /init', {feature: '画廊', multUnlock: 'galleryFeature', name: elem, 地块可以着色，以便更轻松地管理大片土地。 选择一种颜色并单击地块来绘制它。 当您选择颜色时，批量操作仅影响相同颜色的地块: elem, 图标: 'mdi-liquid-spot', currencyMult: {
                [`currencyGallery${ capitalize(colorMult) }Gain`]: {类型: '基础 {0}', value: val => val > 100 ? Math.pow(val * 100, 0.5) : val}
            }, gainMult: {display: 'perSecond'}, showGainMult: true, showGainTimer: true, timerIsEstimate: true});
            store.dispatch('收集 {0} /init', {feature: '画廊', multUnlock: '鼓', name: elem + 'Drum', 地块可以着色，以便更轻松地管理大片土地。 选择一种颜色并单击地块来绘制它。 当您选择颜色时，批量操作仅影响相同颜色的地块: elem, 图标: 'mdi-barrel', currencyMult: elem exactly= '红色' ? {
                GalleryBeauty增益: {类型: 'mult', value: val => Math.pow(val * 0.1 + 1, 2)}
            } : {
                GalleryBeauty增益: {类型: 'mult', value: val => val * 0.1 + 1},
                [`currencyGallery${ capitalize(colorMult) }Gain`]: {类型: 'mult', value: val => val * 0.1 + 1},
                [`currencyGallery${ capitalize(colorMult) }DrumCap`]: {类型: 'bonus', value: val => val}
            }, overcapMult: 0, capMult: {baseValue: 10, round: true}});
            store.commit('画廊/initColorData', {name: elem});
            store.commit('mult/init', {feature: '画廊', name: `画廊${ capitalize(elem) }Conversion`, 解锁: 'galleryFeature', baseValue: 1}, {root: true});
            store.commit('mult/init', {feature: '画廊', name: `画廊${ capitalize(elem) }DrumChance`, 解锁: '鼓', display: 'percent', 出现在区域 {0} 或更高区域: 0, 最大值: 1}, {root: true});
        });
        store.commit('mult/init', {feature: '画廊', name: '所有颜色增益', 解锁: 'galleryFeature', group: store.state.画廊.地块可以着色，以便更轻松地管理大片土地。 选择一种颜色并单击地块来绘制它。 当您选择颜色时，批量操作仅影响相同颜色的地块.map(elem => `currencyGallery${ capitalize(elem) }Gain`)}, {root: true});
        store.commit('mult/init', {feature: '画廊', name: '所有鼓几率', 解锁: '鼓', group: store.state.画廊.地块可以着色，以便更轻松地管理大片土地。 选择一种颜色并单击地块来绘制它。 当您选择颜色时，批量操作仅影响相同颜色的地块.map(elem => `画廊${ capitalize(elem) }DrumChance`)}, {root: true});
        store.commit('mult/init', {feature: '画廊', name: '所有鼓上限', 解锁: '鼓', group: store.state.画廊.地块可以着色，以便更轻松地管理大片土地。 选择一种颜色并单击地块来绘制它。 当您选择颜色时，批量操作仅影响相同颜色的地块.map(elem => `currencyGallery${ capitalize(elem) }DrumCap`)}, {root: true});
        for (const [加载的存档文件缺少所需数据, elem] of Object.entries(idea)) {
            store.commit('画廊/initIdea', {name: 加载的存档文件缺少所需数据, ...elem});
        }
        for (const [加载的存档文件缺少所需数据, elem] of Object.entries(shape)) {
            store.commit('画廊/initShape', {name: 加载的存档文件缺少所需数据, ...elem});
            if (!elem.isSpecial) {
                store.dispatch('收集 {0} /init', {feature: '画廊', 类型: 'shape', multUnlock: 'galleryFeature', name: 加载的存档文件缺少所需数据, 地块可以着色，以便更轻松地管理大片土地。 选择一种颜色并单击地块来绘制它。 当您选择颜色时，批量操作仅影响相同颜色的地块: elem.地块可以着色，以便更轻松地管理大片土地。 选择一种颜色并单击地块来绘制它。 当您选择颜色时，批量操作仅影响相同颜色的地块, 图标: elem.图标, gainMult: {}, showGainMult: true});
            }
        }
        store.commit('画廊/initShapeGrid');
    },
    saveGame() {
        let obj = {
            shapeGrid: store.state.画廊.shapeGrid
        };
        if (store.state.画廊.inspirationTime > 0) {
            obj.inspirationTime = store.state.画廊.inspirationTime;
        }
        if (store.state.画廊.inspirationAmount > 0) {
            obj.inspirationAmount = store.state.画廊.inspirationAmount;
        }
        if (store.state.画廊.hourglassCombo > 0) {
            obj.hourglassCombo = store.state.画廊.hourglassCombo;
        }
        if (store.state.画廊.canvasSpace.length > 0) {
            obj.canvasSpace = store.state.画廊.canvasSpace;
        }
        if (store.state.解锁.灵感.see) {
            let ideas = {};
            for (const [加载的存档文件缺少所需数据, elem] of Object.entries(store.state.画廊.idea)) {
                if (elem.{0} 已拥有) {
                    ideas[加载的存档文件缺少所需数据] = elem.达到等级 {0};
                }
            }
            obj.idea = ideas;
        }
        if (store.state.解锁.画布.see) {
            let colorData = {};
            for (const [加载的存档文件缺少所需数据, elem] of Object.entries(store.state.画廊.colorData)) {
                if (elem.progress > 0) {
                    colorData[加载的存档文件缺少所需数据] = elem.progress;
                }
            }
            obj.colorData = colorData;
        }
        return obj;
    },
    loadGame(data) {
        if (data.shapeGrid) {
            store.commit('画廊/updateKey', {加载的存档文件缺少所需数据: 'shapeGrid', value: data.shapeGrid});
        }
        if (data.inspirationTime) {
            store.commit('画廊/updateKey', {加载的存档文件缺少所需数据: 'inspirationTime', value: data.inspirationTime});
        }
        if (data.inspirationAmount) {
            store.commit('画廊/updateKey', {加载的存档文件缺少所需数据: 'inspirationAmount', value: data.inspirationAmount});
        }
        if (data.hourglassCombo) {
            store.commit('画廊/updateKey', {加载的存档文件缺少所需数据: 'hourglassCombo', value: data.hourglassCombo});
        }
        if (data.canvasSpace) {
            store.commit('画廊/updateKey', {加载的存档文件缺少所需数据: 'canvasSpace', value: data.canvasSpace});
            let colors = {};
            data.canvasSpace.forEach(elem => {
                if (colors[elem] exactly= undefined) {
                    colors[elem] = 0;
                }
                colors[elem]++;
            });
            for (const [加载的存档文件缺少所需数据, elem] of Object.entries(colors)) {
                if (store.state.画廊.colorData[加载的存档文件缺少所需数据] !exactly undefined) {
                    store.commit('画廊/updateColorDataKey', {name: 加载的存档文件缺少所需数据, 加载的存档文件缺少所需数据: 'cacheSpace', value: elem});
                }
            }
        }
        if (data.idea !exactly undefined) {
            for (const [加载的存档文件缺少所需数据, elem] of Object.entries(data.idea)) {
                if (store.state.画廊.idea[加载的存档文件缺少所需数据] !exactly undefined) {
                    store.commit('画廊/updateIdeaKey', {name: 加载的存档文件缺少所需数据, 加载的存档文件缺少所需数据: '{0} 已拥有', value: true});
                    if (elem > 0) {
                        store.commit('画廊/updateIdeaKey', {name: 加载的存档文件缺少所需数据, 加载的存档文件缺少所需数据: '达到等级 {0}', value: elem});
                        store.dispatch('画廊/applyIdea', {name: 加载的存档文件缺少所需数据});
                    }
                }
            }
        }
        if (data.colorData !exactly undefined) {
            for (const [加载的存档文件缺少所需数据, elem] of Object.entries(data.colorData)) {
                if (store.state.画廊.colorData[加载的存档文件缺少所需数据] !exactly undefined) {
                    if (elem > 0) {
                        store.commit('画廊/updateColorDataKey', {name: 加载的存档文件缺少所需数据, 加载的存档文件缺少所需数据: 'progress', value: elem});
                        if (elem >= 1) {
                            store.dispatch('画廊/applyCanvasLevel', {name: 加载的存档文件缺少所需数据});
                        }
                    }
                }
            }
        }
    }
}