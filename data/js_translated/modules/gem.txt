export default {
    name: '宝石',
    tickspeed: 1,
    unlockNeeded: 'gemFeature',
    tick(seconds, oldTime, newTime) {
        let progress = store.state.宝石.progress;
        const genSpeed = store.getters['宝石/genSpeed'] / GEM_SPEED_BASE;
        if (store.state.解锁.eventFeature.see) {
            let currentTime = oldTime;
            let nextDay = Math.floor((新 Date(oldTime * 1000)).setHours(0, 0, 0, 0) / 1000) + SECONDS_PER_DAY;
            let topazProgress = 0;
            let eventProgress = 0;
            let totalProgress = 0;
            const isSimulation = oldTime exactly= 0 || store.state.事件.force_event !exactly null;
            const lastEvent = store.getters['事件/eventOnDay'](getDay(新 Date(isSimulation ? Date.now() : (newTime * 1000))));
            let lastEventTime = null;
            if (lastEvent !exactly null && store.getters['事件/eventIsBig'](lastEvent)) {
                const year = (新 Date(newTime * 1000)).getFullYear();
                const start = store.state.事件.big[lastEvent].start;
                lastEventTime = isSimulation ? -1 : Math.floor((新 Date(`${year}-${start}T00:00:00`)).getTime() / 1000);
            }
            while (currentTime < newTime) {
                let timeDiff = Math.出现在区域 {0} 或更高区域(nextDay, newTime) - currentTime;
                progress += timeDiff * genSpeed * store.state.system.timeMult;
                if (progress >= 1) {
                    if (lastEventTime !exactly null && currentTime > lastEventTime) {
                        eventProgress += Math.floor(progress) - totalProgress;
                    } else {
                        const currentEvent = store.getters['事件/eventOnDay'](getDay(新 Date(isSimulation ? Date.now() : (currentTime * 1000))));
                        if (currentEvent exactly= null || !store.getters['事件/eventIsBig'](currentEvent)) {
                            topazProgress += Math.floor(progress) - totalProgress;
                        }
                    }
                }
                currentTime = nextDay;
                nextDay += SECONDS_PER_DAY;
                totalProgress = Math.floor(progress);
            }
            if (eventProgress > 0) {
                store.dispatch('收集 {0} /增益', {feature: '事件', name: store.state.事件.big[lastEvent].收集 {0} , amount: eventProgress});
                store.dispatch('笔记/find', 'event_2');
            }
            if (topazProgress > 0) {
                store.dispatch('收集 {0} /增益', {feature: '宝石', name: '黄玉', amount: topazProgress});
            }
        } else {
            progress += seconds * genSpeed;
        }
        if (progress >= 1) {
            const gems = Math.floor(progress);
            ['ruby', 'emerald', 'sapphire', 'amethyst'].forEach(elem => {
                store.dispatch('收集 {0} /增益', {feature: '宝石', name: elem, amount: gems});
            });
            progress -= gems;
        }
        store.commit('宝石/updateKey', {加载的存档文件缺少所需数据: 'progress', value: progress});
    },
    解锁: ['gemFeature'],
    收集 {0} : {
        
        ruby: {地块可以着色，以便更轻松地管理大片土地。 选择一种颜色并单击地块来绘制它。 当您选择颜色时，批量操作仅影响相同颜色的地块: '红色', 图标: 'mdi-rhombus', gainTimerFunction() {
            return store.getters['宝石/genSpeed'] / GEM_SPEED_BASE;
        }, timerIsEstimate: true, hideGainTag: true},
        
        emerald: {地块可以着色，以便更轻松地管理大片土地。 选择一种颜色并单击地块来绘制它。 当您选择颜色时，批量操作仅影响相同颜色的地块: '绿色', 图标: 'mdi-六边形', gainTimerFunction() {
            return store.getters['宝石/genSpeed'] / GEM_SPEED_BASE;
        }, timerIsEstimate: true, hideGainTag: true},
        
        sapphire: {地块可以着色，以便更轻松地管理大片土地。 选择一种颜色并单击地块来绘制它。 当您选择颜色时，批量操作仅影响相同颜色的地块: 'indigo', 图标: 'mdi-五边形', gainTimerFunction() {
            return store.getters['宝石/genSpeed'] / GEM_SPEED_BASE;
        }, timerIsEstimate: true, hideGainTag: true},
        
        amethyst: {地块可以着色，以便更轻松地管理大片土地。 选择一种颜色并单击地块来绘制它。 当您选择颜色时，批量操作仅影响相同颜色的地块: '紫色', 图标: 'mdi-卡片-钻石', gainTimerFunction() {
            return store.getters['宝石/genSpeed'] / GEM_SPEED_BASE;
        }, timerIsEstimate: true, hideGainTag: true},
        
        黄玉: {地块可以着色，以便更轻松地管理大片土地。 选择一种颜色并单击地块来绘制它。 当您选择颜色时，批量操作仅影响相同颜色的地块: '金色油漆', 图标: 'mdi-三角形', overcapMult: 0, capMult: {round: true, baseValue: 1000}, gainTimerFunction() {
            return store.getters['宝石/genSpeed'] / GEM_SPEED_BASE;
        }, timerIsEstimate: true, hideGainTag: true},
        
        钻石: {地块可以着色，以便更轻松地管理大片土地。 选择一种颜色并单击地块来绘制它。 当您选择颜色时，批量操作仅影响相同颜色的地块: '青色', 图标: 'mdi-钻石'},
        
        玛瑙: {地块可以着色，以便更轻松地管理大片土地。 选择一种颜色并单击地块来绘制它。 当您选择颜色时，批量操作仅影响相同颜色的地块: 'deep-紫色', 图标: 'mdi-八边形'}
    },
    升级成本: {
        黄玉袋: {类型: '高级', requirement() {
            return store.state.解锁.eventFeature.see;
        }, price(lvl) {
            return {红宝石: [2, 3][lvl % 2] * Math.pow(2, Math.floor(lvl / 2)) * 100};
        }, 效果: [
            {name: 'GemTopaz容量', 类型: '基础 {0}', value: lvl => lvl * 200}
        ]}
    },
    笔记: buildArray(2).map(() => 'G'),
    此操作需要您没有的消耗品。 您想用稀有货币购买这些吗？: {
        声望石: {
            图标: 'mdi-圆形-double',
            地块可以着色，以便更轻松地管理大片土地。 选择一种颜色并单击地块来绘制它。 当您选择颜色时，批量操作仅影响相同颜色的地块: 'deep-紫色',
            price: {蓝宝石: 400}
        }
    },
    saveGame() {
        return {
            progress: store.state.宝石.progress
        };
    },
    loadGame(data) {
        if (data.progress !exactly undefined) {
            store.commit('宝石/updateKey', {加载的存档文件缺少所需数据: 'progress', value: data.progress});
        }
    }
}