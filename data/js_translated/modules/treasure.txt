return {
        层: item.层,
        类型: item.类型,
        达到等级 {0}: item.达到等级 {0},
        fragmentsSpent: item.fragmentsSpent,
        图标: item.图标,
        效果: item.效果.map(el => store.state.宝藏.effectToFeature[el] ? el : fallbackEffect)
    }
}
    普通效果: {
        buyPrice: 30,
        upgradePrice: 10,
        upgradeLimit: 4,
        upgradeScaling: 1.25,
        destroyPrice: 8,
        slots: [
            {类型: '普通效果', 攻击和生命值 x{0}: 1}
        ]
    },
    dual: {
        buyPrice: 75,
        upgradePrice: 25,
        upgradeLimit: 4,
        upgradeScaling: 1.25,
        destroyPrice: 20,
        slots: [
            {类型: '普通效果', 攻击和生命值 x{0}: 0.7},
            {类型: '普通效果', 攻击和生命值 x{0}: 0.7}
        ],
        图标: 'mdi-call-split'
    },
    empowered: {
        destroyPrice: 32,
        slots: [
            {类型: '普通效果', 攻击和生命值 x{0}: 1}
        ],
        图标: 'mdi-星形-圆形'
    },
    ancient: {
        destroyPrice: 28,
        slots: [
            {类型: '特殊效果', 攻击和生命值 x{0}: 1}
        ],
        图标: 'mdi-eye-圆形'
    }
};
let treasureRng = [];
for (const [加载的存档文件缺少所需数据] of Object.entries(treasureTypes)) {
    treasureRng.push(`treasure_${加载的存档文件缺少所需数据}`);
}
export default {
    name: '宝藏',
    unlockNeeded: 'treasureFeature',
    解锁: ['treasureFeature', 'treasureSpecialEffect', '双宝'],
    mult: {
        宝藏插槽: {round: true, baseValue: 10}
    },
    收集 {0} : {
        碎片: {地块可以着色，以便更轻松地管理大片土地。 选择一种颜色并单击地块来绘制它。 当您选择颜色时，批量操作仅影响相同颜色的地块: '金色油漆', 图标: 'mdi-shimmer', gainMult: {}}
    },
    升级成本: upgradePremium,
    rng: treasureRng,
    笔记: buildArray(3).map(() => 'G'),
    init() {
        for (const [加载的存档文件缺少所需数据, elem] of Object.entries(效果)) {
            store.commit('宝藏/initEffect', {name: 加载的存档文件缺少所需数据, ...elem});
        }
        for (const [加载的存档文件缺少所需数据, elem] of Object.entries(treasureTypes)) {
            store.commit('宝藏/initType', {name: 加载的存档文件缺少所需数据, ...elem});
        }
    },
    saveGame() {
        return {
            items: store.state.宝藏.items.map(elem => elem ? filterItem(elem) : null),
            newItem: store.state.宝藏.newItem ? filterItem(store.state.宝藏.newItem) : null
        };
    },
    loadGame(data) {
        if (data.items) {
            store.commit('宝藏/updateKey', {加载的存档文件缺少所需数据: 'items', value: data.items.map(elem => elem ? {
                ...filterItem(elem),
                valueCache: elem.效果.map(el => store.state.宝藏.effectToFeature[el] ? el : fallbackEffect).map((el, i) => store.getters['宝藏/effectValue'](
                    store.state.宝藏.效果[store.state.宝藏.effectToFeature[el]][el].value * store.state.宝藏.类型[elem.类型].slots[i].攻击和生命值 x{0},
                    elem.层,
                    elem.达到等级 {0},
                    elem.类型
                ))
            } : null)});
        }
        if (data.newItem) {
            store.commit('宝藏/updateKey', {加载的存档文件缺少所需数据: 'newItem', value: {
                ...filterItem(data.newItem),
                valueCache: data.newItem.效果.map(el => store.state.宝藏.effectToFeature[el] ? el : fallbackEffect).map((el, i) => store.getters['宝藏/effectValue'](
                    store.state.宝藏.效果[store.state.宝藏.effectToFeature[el]][el].value * store.state.宝藏.类型[data.newItem.类型].slots[i].攻击和生命值 x{0},
                    data.newItem.层,
                    data.newItem.达到等级 {0},
                    data.newItem.类型
                ))
            }});
        }
        store.dispatch('宝藏/updateEffectCache');
    }
}